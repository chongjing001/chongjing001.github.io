<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[~火影~]]></title>
    <url>%2F2019%2F01%2F28%2F~%E7%81%AB%E5%BD%B1~%2F</url>
    <content type="text"><![CDATA[1&lt;iframe height=498 width=510 src='http://player.youku.com/embed/XMzcyNjU4ODA2MA==' frameborder=0 'allowfullscreen'&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>曾经的青春</category>
      </categories>
      <tags>
        <tag>没有为什么</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django基础（一）- 搭建基本的网站]]></title>
    <url>%2F2019%2F01%2F02%2FdjangoDay1%2F</url>
    <content type="text"><![CDATA[虚拟环境： 安装：pip install virtualenv 使用： virtualenv –no-site-packages -p 环境位置 项目名 --no-site-packages:表示创建的环境为纯净环境，不安装其他的 pip使用： pip list : 查看安装的库 pip install xxx: 安装 激活虚拟环境： winows: activate mac/linux : 直接执行scurce activat 注意：要到环境文件中激活虚拟环境 退出虚拟环境 deactivate Django项目创建：django-admin startproject 项目名称注意切换到你的代码文件目录下创建 启动命令： python manage.py runserver 默认ip为127.0.0.1 默认端口为8000 修改启动端口： python manage.py runserver 端口修改ip和端口： python manage.py runserver ip:端口 ip参数：0.0.0.0 表示任何人都可以通过公网ip访问Django项目 端口prot参数：如果端口设置为80，表示改端口可以不用写在pycharm中切换为上面创建的虚拟环境，执行启动命令，结果如下：打开上图网址，最基本的Django框架就OK了 settings.py配置文件设置 语言设置LANGUAGE_CODE = ‘zh-hans’ 表示中文 LANGUAGE_CODE = ‘en-us’ 表示英文设置时区：TIME_ZONE = ‘Asia/Shanghai’时区默认是UTC：世界标准时间，也就是平常说的零时区。 北京时间表示东八区时间，即UTC+8再打开网页刷新一下 连接数据库修改配置文件12345678910111213141516171819# 原配置DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125;# 修改后的DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': '数据库名', # 要是存在的数据库 'PORT': '端口（MySQL默认的为3306）', 'USER': '用户名', # MySQL的用户名和密码 'PASSWORD' : '密码', 'HOST' : 'MySQL服务器的ip地址' &#125;&#125; 需要安装MySQL客户端在创建Terminal中输入 pip install pymysql 即可12345# 安装pymysql：使用pymysql连接数据库：因为python3没有MySQLdb驱动，无法直接连接MySQL# 在工程目录的__init__.py文件中加入import pymysqlpymysql.install_as_MySQLdb() 在上面的网址后面加上admin，(http://127.0.0.1:8000/admin)再访问 添加账号 迁移：迁移默认文件：python manage.py migrate添加管理员账号：python manage.py createsuperuser现在在运行服务器就可以用刚才创建的账号登陆了 以上就是django基础框架搭建自定义模板待续… 补充：MVC（model,view,controller）模式是所有框架遵循的模式 M: 模型（M）是数据的表述。它不是真正的数据，而是数据的接口。使用模型从数据库中获取数据时，无需知道底层数据库错综复杂的知识。模型通常还会为数据库提供一层抽象，这样同一个模型就能使用不同的数据库 V: 视图（V）是你看到的界面。它是模型的表现层。在电脑中，视图是你在浏览器中看到的 Web 应用的页面，或者是桌面应用的 UI。视图还提供了收集用户输入的接口 C: controller，控制器 控制模型和视图之间的信息流动。它通过程序逻辑判断通过模型从数据库中获取什么信息，以及把什么信息传给视图。它还通过视图从用户那里收集信息，并且实现业务逻辑：变更视图，或者通过模型修改数据，或者二者兼具 严格来说，Django的模式应该是MVT模式，本质上和MVC没什么区别，也是各组件之间为了保持松耦合关系，只是定义上有些许不同MVT (model,view,template )： M： models.py 模型层：定义模型和数据库中表 V: views.py 视图层：定义业务逻辑 T: templates 模板，定义HTML的地方 MVT模式是由MVT模式演变出来的]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>网站搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础 String（字符串）- 常用指令]]></title>
    <url>%2F2018%2F12%2F28%2FRedis%E5%9F%BA%E7%A1%80-String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89--%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1.set - 创建键值对 例：set abc 123 2.get - 获取键值对 get abc 3.setbit - bit默认初始化为0 123456redis&gt;setbit num 100 1(integer)0redis&gt;setbit num 99 # 除100其他数都返回0（integer）0redis&gt;setbit num 100 (interger)1 4.setex - 产生键值对，并设置存活时间，如果key值存在则覆盖 1234567891011121314151617#当keys不存在时进行setexredis&gt;setex number 60 1000OKredis&gt;get number &apos;1000&apos;redis&gt;ttl number #剩余生存时间(integer)50#key存在时，setex覆盖旧值redis&gt;setex name 旧值OKredis&gt;setex name 100 &apos;新值&apos;OKredis&gt;get name&apos;新值&apos;redis&gt;ttl name(integer)90 5.exists - 当key值不存在时，可以创建，存在时创建失败 12345678910111213141516171819202122# 对非空字符串进行 SETRANGEredis&gt; SET greeting &quot;hello world&quot;OKredis&gt; SETRANGE greeting 6 &quot;Redis&quot;(integer) 11redis&gt; GET greeting&quot;hello Redis&quot;# 对空字符串/不存在的 key 进行 SETRANGEredis&gt; EXISTS empty_string(integer) 0redis&gt; SETRANGE empty_string 5 &quot;Redis!&quot; # 对不存在的 key 使用 SETRANGE(integer) 11redis&gt; GET empty_string # 空白处被&quot;\x00&quot;填充&quot;\x00\x00\x00\x00\x00Redis! 6.setlen - 获取字符串的长度 12345678redis&gt;set n1 &apos;hello world&apos;OKredis&gt;setlen n1(integer)11# 不存在的key长度为0redis&gt;strlen n2(integer)0 7.mset/mget 同时设置/获取多个键值对 1234567redis&gt; mset a 1 b 2 c 3OKredis&gt;mget a b c1)&apos;1&apos;2)&apos;2&apos;3)&apos;3&apos;注意：mset会覆盖旧值 8 incr - key的值加一 123456redis&gt;set num 20OKredis&gt;incr num(integer)21redis&gt;get num # 数字在redis中以字符串的形式保存&apos;21&apos; 9 incrby 当key不存在时可以创建，key不是数字时后报错 12345678910111213141516171819202122232425262728293031# key 存在且是数字值redis&gt; SET rank 50OKredis&gt; INCRBY rank 20(integer) 70redis&gt; GET rank&quot;70&quot;# key 不存在时redis&gt; EXISTS counter(integer) 0redis&gt; INCRBY counter 30(integer) 30redis&gt; GET counter&quot;30&quot;# key 不是数字值时redis&gt; SET book &quot;long long ago...&quot;OKredis&gt; INCRBY book 200(error) ERR value is not an integer or out of range 10 decr/ decrby 用法和和上面相同，不同的是 key - 1 11 append - 如果 key 已经存在并且是一个字符串， append 命令将 value 追加到 key 原来的值的末尾;如果 key 不存在， append 就简单地将给定 key 设为 value ，就像执行 set key value 一样。 Redis的list类型 - 经典数据存储结构：栈（stack）- FILO - 先进后出 lpush + lpop / rpush + rpop队列（queue） - FILO - 先进先出lpush + rpop / rpush + lpop]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基本使用(一)]]></title>
    <url>%2F2018%2F12%2F27%2FMySQL%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[MySQL建库和建表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306-- 如果存在名为SRS的数据库就删除它（慎重！！！) drop database if exists SRS;-- 创建名为SRS的数据库并设置默认字符集为utf8（如果不设定，出现中文会乱码）create database SRS default charset utf8 collate utf8_bin;-- 切换到SRS数据库use SRS;-- 创建学院表create table tb_college(collid int not null auto_increment comment '学院编号',collname varchar(50) not null comment '学院名称',collmaster varchar(20) not null comment '院长姓名',collweb varchar(511) default '' comment '学院网站',primary key (collid));-- 添加唯一约束alter table tb_college add constraint uni_college_collname unique (collname);-- 创建学生表create table tb_student(stuid int not null comment '学号',sname varchar(20) not null comment '学生姓名',gender bit default 1 comment '性别',birth date not null comment '出生日期',addr varchar(255) default '' comment '籍贯',collid int not null comment '所属学院编号',primary key (stuid));-- 添加外键约束alter table tb_student add constraint fk_student_collid foreign key (collid) references tb_college (collid);-- 创建教师表create table tb_teacher(teaid int not null comment '教师工号',tname varchar(20) not null comment '教师姓名',title varchar(10) default '' comment '职称',collid int not null comment '所属学院编号');-- 添加主键约束alter table tb_teacher add constraint pk_teacher primary key (teaid);-- 添加外键约束alter table tb_teacher add constraint fk_teacher_collid foreign key (collid) references tb_college (collid);-- 创建课程表create table tb_course(couid int not null comment '课程编号',cname varchar(50) not null comment '课程名称',credit tinyint not null comment '学分',teaid int not null comment '教师工号',primary key (couid));-- 添加外键约束alter table tb_course add constraint fk_course_tid foreign key (teaid) references tb_teacher (teaid);-- 创建学生选课表create table tb_score(scid int not null auto_increment comment '选课编号',sid int not null comment '学号',cid int not null comment '课程编号',seldate date comment '选课时间日期',mark decimal(4,1) comment '考试成绩',primary key (scid));-- 添加外键约束alter table tb_score add constraint fk_score_sid foreign key (sid) references tb_student (stuid);alter table tb_score add constraint fk_score_cid foreign key (cid) references tb_course (couid);-- 添加唯一约束alter table tb_score add constraint uni_score_sid_cid unique (sid, cid);-- 插入学院数据insert into tb_college (collname, collmaster, collweb) values ('计算机学院', '左冷禅', 'http://www.abc.com'),('外国语学院', '岳不群', 'http://www.xyz.com'),('经济管理学院', '风清扬', 'http://www.foo.com');-- 插入学生数据insert into tb_student (stuid, sname, gender, birth, addr, collid) values(1001, '杨逍', 1, '1990-3-4', '四川成都', 1),(1002, '任我行', 1, '1992-2-2', '湖南长沙', 1),(1033, '王语嫣', 0, '1989-12-3', '四川成都', 1),(1572, '岳不群', 1, '1993-7-19', '陕西咸阳', 1),(1378, '纪嫣然', 0, '1995-8-12', '四川绵阳', 1),(1954, '林平之', 1, '1994-9-20', '福建莆田', 1),(2035, '东方不败', 1, '1988-6-30', null, 2),(3011, '林震南', 1, '1985-12-12', '福建莆田', 3),(3755, '项少龙', 1, '1993-1-25', null, 3),(3923, '杨不悔', 0, '1985-4-17', '四川成都', 3);-- 插入老师数据insert into tb_teacher (teaid, tname, title, collid) values (1122, '张三丰', '教授', 1),(1133, '宋远桥', '副教授', 1),(1144, '杨逍', '副教授', 1),(2255, '范遥', '副教授', 2),(3366, '韦一笑', '讲师', 3);-- 插入课程数据insert into tb_course (couid, cname, credit, teaid) values (1111, 'Python程序设计', 3, 1122),(2222, 'Web前端开发', 2, 1122),(3333, '操作系统', 4, 1122),(4444, '计算机网络', 2, 1133),(5555, '编译原理', 4, 1144),(6666, '算法和数据结构', 3, 1144),(7777, '经贸法语', 3, 2255),(8888, '成本会计', 2, 3366),(9999, '审计学', 3, 3366);-- 插入选课数据insert into tb_score (sid, cid, seldate, mark) values (1001, 1111, '2017-09-01', 95),(1001, 2222, '2017-09-01', 87.5),(1001, 3333, '2017-09-01', 100),(1001, 4444, '2018-09-03', null),(1001, 6666, '2017-09-02', 100),(1002, 1111, '2017-09-03', 65),(1002, 5555, '2017-09-01', 42),(1033, 1111, '2017-09-03', 92.5),(1033, 4444, '2017-09-01', 78),(1033, 5555, '2017-09-01', 82.5),(1572, 1111, '2017-09-02', 78),(1378, 1111, '2017-09-05', 82),(1378, 7777, '2017-09-02', 65.5),(2035, 7777, '2018-09-03', 88),(2035, 9999, date(now()), null),(3755, 1111, date(now()), null),(3755, 8888, date(now()), null),(3755, 9999, '2017-09-01', 92);-- 查询所有学生信息select * from tb_student;-- 查询所有课程名称及学分(投影和别名)select cname as 课程名称, credit as 学分 from tb_course;-- as 可以省略 -- 查询所有女学生的姓名和出生日期(筛选)select sname 姓名, birth 出生日期 from tb_student where gender=0;-- 查询所有80后学生的姓名、性别和出生日期(筛选)select sname 姓名, case gender when 1 then '男' else '女' end 性别, birth 出生日期 from tb_student where birth between '1980-1-1' and '1989-12-31';-- 写法二 使用函数select sname 姓名, if (gender, '男','女') 性别, birth 出生日期 from tb_student where birth between '1980-1-1' and '1989-12-31';-- 查询名字有4个中文字符的学生学号和姓名（函数）-- utf-8 一个字符=三个字节select stuid as 学号,sname as 姓名 from tb_studentwhere length(sname)/3=4;-- 查询姓”杨“的学生姓名和性别(模糊)select sname 姓名,if (gender,'男','女') as 性别from tb_student where sname like '杨%';-- 查询姓”杨“名字两个字的学生姓名和性别(模糊)select sname 姓名,if (gender,'男','女') as 性别from tb_student where sname like '杨_';-- 查询姓”杨“名字三个字的学生姓名和性别(模糊)select sname 姓名,if (gender,'男','女') as 性别from tb_student where sname like '杨__';-- 查询名字中有”不“字或“嫣”字的学生的姓名(模糊)select sname 姓名,if (gender,'男','女') as 性别from tb_student where sname like '%不%' or sname like'%嫣%';-- 查询没有录入家庭住址的学生姓名(空值)select sname 姓名 from tb_student where addr is null or addr = ''; -- 查询录入了家庭住址的学生姓名(空值)select sname 姓名 from tb_student where addr is not null and addr &lt;&gt; '';-- 查询学生选课的所有日期(去重)select distinct seldate from tb_score;-- 查询学生的家庭住址(去重)select distinct addr from tb_student where addr is not null and addr &lt;&gt; '';-- 查询男学生的姓名和生日按年龄从大到小排列(排序)-- asc (默认) 升序 / desc 降序select sname 姓名,birth 出生日期 from tb_studentwhere gender = 1 order by birth desc;select sname 姓名,year(now())-year(birth) as 年龄 from tb_student where gender=1 order by 年龄 desc;select stuid 学号,sname 姓名,gender 出生日期 from tb_studentorder by gender asc, stuid desc;-- 聚合函数： max/ min / sum /avg / count-- 查询年龄最大的学生的出生日期(聚合函数)select min(birth) from tb_student;-- 查询年龄最小的学生的出生日期(聚合函数)select max(birth) from tb_student;-- 查询男女学生的人数(分组和聚合函数)select if(gender,'男','女') 性别, count(gender) 人数 from tb_studentgroup by gender;-- 查询课程编号为1111的课程的平均成绩(筛选和聚合函数)select avg(mark)as 平均成绩 from tb_score where cid = 1111;-- 查询学号为1001的学生所有课程的平均分(筛选和聚合函数)select avg(mark) 平均成绩 from tb_score where sid = 1001;-- 查询每个学生的学号和平均成绩(分组和聚合函数)select sid 学号, avg(mark) 平均分 from tb_scoregroup by sid;-- 查询平均成绩大于等于90分的学生的学号和平均成绩select sid 学号, avg(mark) 平均分 from tb_scoregroup by sid having 平均分&gt;=90;-- 查询平均成绩大于等于90分的学生且学号为1开头学号的 学号和平均成绩-- where 用于分组之前的筛选， 分组之后用 havingselect sid 学号, avg(mark) 平均分 from tb_scorewhere sid between 1000 and 1999 group by sid having 平均分&gt;=90order by 平均分 desc;-- 查询年龄最大的学生的姓名(子查询)select sname 姓名 from tb_studentwhere birth=(select min(birth) from tb_student);-- 查询年龄最大的学生姓名和年龄(子查询+运算)-- 把一个查询的结果当成另一个查询的一部分来使用select sname 姓名, from tb_studentwhere birth=(select min(birth) from tb_student);-- 查询选了两门以上的课程的学生姓名(子查询/分组条件/集合运算)select sname 姓名 from tb_studentwhere stuid in(select sid from tb_score group by sid having count(sid)&gt;2)-- 查询学生姓名、课程名称以及成绩(连接查询)select sname , cname, markfrom tb_student, tb_course, tb_scorewhere stuid=sid and couid=cid limit 5 offset 10;-- 分页查询select sname 学生姓名, cname 课程名称, mark 考试成绩from tb_student inner join tb_score on stuid=sidinner join tb_course on couid=cid limit 5 offset 15;select sname 学生姓名, cname 课程名称, mark 考试成绩from tb_student inner join tb_score on stuid=sidinner join tb_course on couid=cid limit 15,5;-- 查询选课学生的姓名和平均成绩(子查询和连接查询)select sname 姓名, avgmark 平均分from tb_student t1,(select sid, avg(mark) as avgmarkfrom tb_score group by sid) t2where stuid=sid;-- 方法二 内连接select sname 姓名, avgmark 平均分from tb_student t1 inner join(select sid, avg(mark) as avgmarkfrom tb_score group by sid) t2on stuid=sid;-- 查询每个学生的姓名和选课数量(左外连接和子查询)-- 内连接只能将满足连表条件的连表记录查出来-- 左外连接：将左表不满足连表条件的记录查出来 不满足连表条件的地方补null-- 右外连接：将右表不满足连表条件的记录查出来 不满足连表条件的地方补null-- 在连接多表查询时写在前面的表称为左表，写在后面的表称为右表-- left outer join / right outer join -- outer可以省略-- MySQL不支持全外连接 full outer joinselect sname as 姓名, ifnull(total, 0) as 选课数量from tb_student t1left outer join (select sid, count(sid) as totalfrom tb_score group by sid)t2on stuid=sid;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis基础（一）]]></title>
    <url>%2F2018%2F12%2F27%2FRedis%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[安装Redis1234567891011wget http://download.redis.io/releases/redis-5.0.3.tar.gz解包gunzip redis-5.0.3.tar.gztar -xvf redis-5.0.3.tarcd redis-5.0.3编译gcc --version安装make &amp;&amp; make install 提供高速缓存服务 - 缓存热点数据（访问量大数据不大）缓解了数据的压力（高频访问数据不用直接访问数据库）123456789101112131415161718192021222324252627282930启动：redis-server --requirepass 123456 --appendonly yes &gt; redis.log 2&gt; redis-error.log &amp;连接自己的redisredis -cli -h ip -p 端口密码：auth 123456auth - 验证身份ping - 心跳时间set - 设置键值对git - 取值expire - 设置超时时间ttl 内容 - 查看剩余存活时间 -1 永久 -2 超时 - 正整数 剩余时间keys * 查看所有键flushdb - 清空数据库中所有键值对flushall - 清除所有数据库中的所有键值对existis 判断是否存在select 序号（默认有16库） 切换数据库save / bgsave - 保存数据 / 后台保存数据shutdown - 关闭服务器Redis提供两种持久化数据的方案：1. RDB - 默认开启2. AOF - 默认关闭 -- appendonly yes]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL安装(Linux系统)]]></title>
    <url>%2F2018%2F12%2F27%2FMySQL%E5%AE%89%E8%A3%85(Linux%E7%B3%BB%E7%BB%9F)%2F</url>
    <content type="text"><![CDATA[数据库简介数据库 - 实现项目中的数据持久化数据库类别： 关系型数据产品 Oracle - 甲骨文 MySQL - 甲骨文 - MariaDB DB2、SQLServer、PostgreSQL、SQLite 非关系型数据库 NoSQL数据库 - Redis MongoDB - 文档数据库 - 适应量大但是价值低的数据 Rdeis - KV数据库 - 性能好适合做高速缓存服务 ElasticSearch - 搜索引擎 MySQL 特点： 理论基础 ：集合论和关系代数 用二维表来组织数据（行（记录）和列（字段）） 能够唯一标识一条记录的列称为主键（primary key） SQL - 结构化查询语言 DDL - 数据定义语言 - create / drop / alterDML - 数据操作语言 - insert / delete / update / selectDCL - 数据控制语言 - grant / revoke / commit / rollback MySQL服务端安装 Linux安装软件 包管理工具 - yum / rpm Docker - 提供虚拟化服务，创建虚拟化容器并安装软件yum -y install docker-ioyum -y remove docker-ioyum info …yum search …yum list installed | grep docker 启动Docker服务systemctl start dockersystemctl stop dockersystemctl restart dockersystemctl status dockersystemctl enable dockersystemctl disable docker 使用Docker的命令 查看已经下载的镜像文件（安装包）：docker images 下载MySQL的镜像文件：docker pull mysql:5.7 MySQL数据库超级管理员账号 - root 创建并运行容器：docker run -d -p 3306:3306 –name mysql57 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 查看运行中的容器：docker ps 查看所有的容器：docker container ls -a 停止容器docker stop mysql57 启动容器docker start mysql57 删除容器docker rm -f mysql57 安装MySQL客户端工具：Navicat for MySQL - 猫SQLyog - 海豚Toad for MySQL - 蛤蟆]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F12%2F26%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、正则基本符号 1.什么是正则表达式正则表达式就是字符匹配的工具;是由正则符号和普通字符组成，来匹配不同规律的字符串 2.Python对正则表达式的支持python中提供了一个re模块，用来支持正则表达式 fullmatch(正则表达式, 字符串) - 用正则表达式去完全匹配字符串，如果匹配成功返回匹配结果，失败返回Nonepython中的正则表达式的写法：将正则内容写在字符串中，一般这个字符串的最前面会r/R 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import re# 1 普通字符"""普通字符在正则表达式中，代表字符本身"""# 匹配一个字符串，第一个字符是'a',第二个字符是'b',第三个字符也是最后一个字符是'c're_str = r'abc'result = re.fullmatch(re_str, 'abc')print(result)# 2 .(匹配任意字符)"""在正则表达式中，.出现的位置，可以匹配一个任意字符注意：一个.只能匹配一个字符"""# 匹配一个长度上3的字符串，并且第一个字符是'a',最后一个字符是'c',中间是任意字符re_str = r'a.c'result = re.fullmatch(re_str, 'a#c')print(result)# 3 \w(匹配字母数字或者下划线)"""在正则表达式中，\w出现的位置，可以匹配一个任意的字母、数字或者下划线(其实也可以匹配Unicode编码中除了ASCII码剩下的部分)注意：一个\w只能匹配一个字符中文也能匹配"""# 匹配一个长度是5的字符串，并且字符串的前两位是数字、字母和下划线，后面是三个任意字符re_str = r'\w\w...'result = re.fullmatch(re_str, '_好kll')print(result)# 4 \s(匹配空白字符)"""空白字符包括：空格、制表符和换行符(空格,\t,\r,\n)"""# 匹配一个长度是4的字符串，并且字符串前两位是字母数字或者下划线(中文),中间一个空白，再一个字母数字或者下划线(中文)re_str = r'\w\w\s\w'result = re.fullmatch(re_str, 'hj\t8')print(result)# 5 \d(匹配数字字符)# 匹配一个长度是5的字符串，字符串的前三位是数字字符，后两位是任意字符re_str = '\d\d\d..'result = re.fullmatch(re_str, '082de')print(result)# 6 \b(检测单词边界)"""注意：检测\b出现的位置是否是单词边界，不会对字符进行匹配。 当正则表达式中出现了\b，匹配的时候去掉\b，匹配成功后再看\b出现的位置是否是单词边界单词边界：字符串开头、字符串结尾、标点符号、空白符号等（只要能够将单词区分开的符号都属于单词边界）"""# 匹配字符串'hello,world', 并且要求w前面是单词边界, h前面也是单词边界re_str = r'\bhello,\bworld'result = re.fullmatch(re_str, 'hello,world')print(result)&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 3), match='abc'&gt;&lt;re.Match object; span=(0, 3), match='a#c'&gt;&lt;re.Match object; span=(0, 5), match='_好kll'&gt;&lt;re.Match object; span=(0, 4), match='hj\t8'&gt;&lt;re.Match object; span=(0, 5), match='082de'&gt;&lt;re.Match object; span=(0, 11), match='hello,world'&gt; 7 ^(检测字符串开头)在match和fullmatch中没有意义, search、findall等中有意义 8 $(检测字符串结尾 1234# 匹配一个字符串，只有三位，分别是'The',并且e后面是字符串结尾re_str = r'The'result = re.fullmatch(re_str, 'The')print(result) 9 \大写字母 12345678910111213"""'\大写字母'对应的功能是'\小写字母'功能取反 \W - 匹配非数字字母下划线\D - 匹配非数字字符\S - 匹配非空白字符\B - 检测非单词边界"""# 匹配一个字符串，第一个字符是数字、第二个是非数字,第三个是空白，第四个是数字字母下划线，最后一个是a;# 并且要求a前面不是单词边界re_str = r'\d\D\s\w\Ba'result = re.fullmatch(re_str, '9H\t_a')print(result) 10 字符集 123456789101112131415161718192021222324252627282930"""1.[普通字符集] - 匹配中括号出现的任意一个字符例如：[abc] - 匹配一个字符是a或者b或者c注意：a.一个中括号只能匹配一个字符 b.正则中有特殊功能的单个符号在[]都表示符号本身 例如：. $ ^ + * ？ |等 c.匹配字符的组合符号，在中括号中保持原来的功能, 例如: \w \d \s \W \D \S"""# 匹配一个长度是2的字符串，第一个字符是数字，第二个字符是b或者c或者=或者数字re_str = r'\d[bc=\d]'result = re.fullmatch(re_str, '24')print(result)"""2.[字符1-字符2] - 表示字符1到字符2（注意：要求字符1的编码值要小于字符2）[a-z] - 表示匹配所有小写字母[A-Z] - 表示匹配所有大写字母[a-zA-Z] - 匹配所有的字母[1-7] - 匹配数字字符1到7[\u4e00-\u9fa5] - 匹配所有的中文[字符1字符2-] - 这儿的-表示减号本身"""# 匹配一个长度是3的字符串,第一个字符是数字字符1到7中的一个，# 第二个字符是'a'，'b','c','-'中的一个,第三个字符是小写字母re_str = r'[1-7][abc-][a-z]'result = re.fullmatch(re_str, '6-z')print(result)&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 3), match='6-z'&gt; 11 [^字符集] - 匹配不在字符集中的任意一个字符 [^abc] - 匹配除了’a’,’b’,’c’以外的其他任意一个字符[^\d] - 匹配除了数字字符以外的其他任意一个字符[^a-z] - 匹配除了小写字母以外的其他任意一个字符 [abc^] - 匹配’a’,’b’,’c’或者’^’中的任意一个字符12345re_str = r'[^a-z]'result = re.fullmatch(re_str, '是')print(result)&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 1), match='是'&gt; 二、正则控制匹配次数 1 *(匹配0次或者多次) 12345678910111213a* - a出现0次或者多次, '','a','aa', 'aaa'...都可以匹配\d* - 任意数字出现0次或者多次， '','1','12', '3772'...都可以匹配[abc]* - a，b或者c出现0次或者多次[A-F]* - A到F中任意字符出现0次或者多次注意：在[]外面的*的前面需要一个字符或者一个匹配字符的符号print(re.fullmatch(r'a*b', 'aaaaaaaaaab'))print(re.fullmatch(r'[abc]*', 'aabc'))print(re.fullmatch(r"[afadsaf]*",""))&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 11), match='aaaaaaaaaab'&gt;&lt;re.Match object; span=(0, 4), match='aabc'&gt;&lt;re.Match object; span=(0, 0), match=''&gt; 2 +(匹配1次或者多次) 1234567"""a+ - a至少出现一次\d+ - 数字至少出现一次"""print(re.fullmatch(r'a+b', 'ab'))&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 2), match='ab'&gt; ?(匹配0次或者1次) 12345678"""a? - a出现0次或者1次, '', 'a'可以匹配"""# 写一个正则表达式匹配一个整数（正整数和负整数都可以），例如：123， 10， +100， -1234，re_str = r'[-+]?[1-9]\d*'print(re.fullmatch(re_str, '-12'))&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 3), match='-12'&gt; {} 1234567891011121314151617181920"""&#123;N&#125; - 匹配N次, 例如： a&#123;3&#125;，匹配三个'a'&#123;M,N&#125; - 匹配M到N次, 例如： a&#123;3, 5&#125;，匹配三个'a' 或者4个'a'或者5个'a'&#123;,N&#125; - 最多匹配N次(0~N) 例如：a&#123;,3&#125;，'','a', 'aa', 'aaa' &#123;M,&#125; - 至少匹配M次 例如：a&#123;3,&#125; , 'aaa', 'aaaa', 'aaaaa'..."""print(re.fullmatch(r'a&#123;3,&#125;', 'aaa'))# 练习：输入密码，要求检查密码输入是否合格(密码由字母和数字组成，数字不开头，6-12位)。给出提示password = input('密码:')re_str = r'[a-zA-Z][\da-zA-Z]&#123;5,11&#125;'result = re.fullmatch(re_str, password)if result: print('输入成功！')else: print('输入有误！')&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 3), match='aaa'&gt;密码:4f5s4afd46as输入有误！ 三、分之、捕获和贪婪 1.分之 条件1 | 条件2 - 匹配条件1或者条件2\d{2}|[a-z] - 匹配两个数字字符或者一个小写字母a\d{2}|\w{2} - 匹配一个a后面两个数字，或者两个数字字母下划线 注意：正则中的分之也会出现短路，当条件1可以匹配，就不会再使用条件2进行匹配1234567891011121314print(re.fullmatch(r'\d&#123;2&#125;|[a-z]', 'z'))print(re.fullmatch(r'a\d&#123;2&#125;|\w&#123;2&#125;', 'sh'))# 练习：写一个正则表达式，匹配所有的数字,包括正的、负的，整数，小数，0# 例如：100, +100, -100, 12.5, -12.5, 0, 0.23, 0.012"""12, 12.34 : [+-]?[1-9]\d*[.]?\d*0.123 : [+-]?0[.]\d+0 : 0"""re_str = r'[-+]?[1-9]\d*[.]?\d*|[+-]?0[.]\d+|0'print(re.fullmatch(re_str, '-0.02'))&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 5), match='-0.02'&gt; 2 () - 捕获和分组 a.分组 - 将括号中的内容作为一个整体 1234567891011# 匹配一个字符串，前三位是'abc',后三位是三个数字或者三个大写字母re_str1 = r'abc\d&#123;3&#125;|abc[A-Z]&#123;3&#125;'re_str2 = r'abc(\d&#123;3&#125;|[A-Z]&#123;3&#125;)'print(re.fullmatch(re_str2, 'abc123'))# 匹配一个字符串，以'数字小写字母'的形式出现3次re_str = r'(\d[a-z])&#123;3&#125;'print(re.fullmatch(re_str, '2s3f4h'))&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 6), match='abc123'&gt;&lt;re.Match object; span=(0, 6), match='2s3f4h'&gt; b 捕获通过正则获取符合条件的子串的时候，可以在正则表达式中加括号，匹配后只获取括号里面匹配到的内容 re.findall(正则表达式，字符串) - 在字符串中去获取符合正则表达式条件的所有的子串,返回一个列表12str1 = 'ahsa783+sdh*92dfjhjj78jhsda67jk'print(re.findall(r'a(\d+)', str1)) # ['783', '67'] c 重复匹配带多个分组的正则表达式中可以分组的后面通过添加’\数字’来重复前面第几个分组中匹配到的内容 说明：\数字 - 这儿的数字代表前面第几个分组; \1代表第一个分组 \2代表第二个分组 3.贪婪 匹配次数后加?就是贪婪匹配：*?, +?, ??, {M,N}?, {M,}? 表示尽可能少的重复12345678re_str = 'a.+?b're_str2 = 'a.+b' # 不使用贪婪str1 = 'xxxahdjbnnkbsssammmbkkk'print(re.findall(re_str2,str1))print(re.findall(re_str, str1))&gt;&gt;&gt;&gt;['ahdjbnnkbsssammmb']['ahdjb', 'ammmb'] 4.转义符号 在正则表达式中可以在有特殊意义或者特殊功能的符号前加\来取消其特殊功能\w - 代表两个字符，分别是’\’和w+ - 代表+字符* - 代表*字符\? - 代表?字符[], (), {}表示字符的时候，前面也要加\ 注意：在中括号中, \必须加\表示\本身，^在最前面加\表示^本身， 在两个字符之间加\表示-本身 四、re模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import re# 1.compile(了解)"""compile(正则表达式) - 将正则表达式转换成正则表达式对象转换成对象后可以通过对象调用对象方法"""re_str = '\d&#123;3&#125;'re_obj = re.compile(re_str)# 调用模块中的函数print(re.fullmatch(re_str, '234'))# 调用对象方法print(re_obj.fullmatch('234'))# 2.match和fullmatch"""a. fullmatch(正则表达式, 字符串) - 完全匹配，从字符串开头匹配到字符串结束b. match(正则表达式, 字符串) - 不完全匹配，只匹配字符串开头匹配成功返回匹配对象，匹配失败返回None"""re_str = r'\d([A-Z]&#123;2&#125;)'result1 = re.fullmatch(re_str, '2HK')print(result1)result2 = re.match(re_str, '8KLsjdddd==')print(result2)# 匹配对象"""1.span - 匹配到的内容的范围，(开始下标, 结束下标), 结束下标取不到匹配对象.span() - 获取整个正则表达式匹配到的范围匹配对象.span(n) - 获取正则表达式中第n个分组匹配到的范围(前提是有分组)"""print(result2.span())print(result2.span(1))"""2.start和end - 获取匹配结果的开始下标和结束下标匹配对象.start()/匹配对象.end() - 获取整个正则表达式匹配到的开始下标/结束下标匹配对象.start(n)/匹配对象.end(n) - 获取正则表达式中第n个分组匹配到的开始/结束下标"""print(result2.start(), result2.end())print(result2.start(1), result2.end(1))"""3.group - 获取匹配到的内容匹配对象.group() - 获取整个正则表达式匹配到的内容匹配对象.group(n) - 获取正则表达式中第n个分组匹配到的内容"""print(result2.group())print(result2.group(1))"""4. string - 获取用来匹配的原字符串匹配对象.string"""print(result2.string)# 3.search"""search(正则表达式, 字符串) - 匹配字符串中第一个满足正则表达式的子串，如果匹配成功返回匹配对象否则返回None """str1 = 'abc123hks362shjjk990kll'result = re.search(r'\d&#123;3&#125;[a-z]&#123;2&#125;', str1)print(result)# 4.split"""split(正则表达式, 字符串) - 在字符串中按照满足正则表达式条件的子串对字符串进行切割, 返回一个列表"""str1 = 'ab+c7hdjd8jss-sk9sjj78s9kk*k'result = re.split(r'\d+|[+*-]+', str1)print(result)# 5.sub"""sub(正则表达式, 新子串, 字符串) - 用新子串替换字符串中满足正则表达式的子串，返回一个替换后的字符串"""str1 = '你丫是傻 叉吗? 我操你大爷的. F u c k you.'result = re.sub(r'[丫操艹]|F\s*u\s*c\s*k|傻\s*叉', '*', str1)print(result)# 6.findall"""findall(正则表达式, 字符串) - 在字符串中获取满足正则表达式的所有的字符，返回一个列表，列表元素是字符串注意：如果这个正则表达式中有一个分组，结果是列表中只那个分组匹配到的结果 如果这个正则表达式中分组的个数大于1，结果是一个列表，列表中的元素是元祖，元祖中是每个分组匹配到的内容"""str1 = 'haja37jjkd89sdhs909nnna238==='result = re.findall(r'[a-zA-Z]&#123;2,&#125;(\d+)([a-z]+?)', str1)print(result)# 7.finditer"""finditer(正则表达式, 字符串) - 获取字符串中满足正则表达式的内容，返回的是一个迭代器，迭代器中的元素是匹配对象"""result = re.finditer(r'[a-zA-Z]&#123;2,&#125;(\d+)([a-z]+?)', str1)print(result)print(next(result))print(next(result))# 思考：写一个自己finditerdef yt_finditer(pattern, string): re1 = re.search(pattern, string) while re1: yield re1 string = string[re1.end():] re1 = re.search(pattern, string)print('============')result = yt_finditer(r'[a-zA-Z]&#123;2,&#125;(\d+)([a-z]+?)', str1)print(next(result))print(next(result))&gt;&gt;&gt;&gt;&lt;re.Match object; span=(0, 3), match='234'&gt;&lt;re.Match object; span=(0, 3), match='234'&gt;&lt;re.Match object; span=(0, 3), match='2HK'&gt;&lt;re.Match object; span=(0, 3), match='8KL'&gt;(0, 3)(1, 3)0 31 38KLKL8KLsjdddd==&lt;re.Match object; span=(3, 8), match='123hk'&gt;['ab', 'c', 'hdjd', 'jss', 'sk', 'sjj', 's', 'kk', 'k']你*是*吗? 我*你大爷的. * you.[('37', 'j'), ('89', 's'), ('909', 'n')]&lt;callable_iterator object at 0x0000022B3679DEF0&gt;&lt;re.Match object; span=(0, 7), match='haja37j'&gt;&lt;re.Match object; span=(7, 13), match='jkd89s'&gt;============&lt;re.Match object; span=(0, 7), match='haja37j'&gt;&lt;re.Match object; span=(0, 6), match='jkd89s'&gt; 下面为常用正则表达式 待续…]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程-socket]]></title>
    <url>%2F2018%2F12%2F26%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%20-%20socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、服务器套接字 socket又叫套接字，指的就是实现通信过程的两个端。等待请求的一端叫服务端套接字，发送请求的一端叫客户端套接字 python中提供了socket模块来支持socket编程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import socket# ==========服务器套接字=============# 1.创建套接字对象"""socket(family, type)family - 设置ip类型 AF_INET(默认值) - ipv4 AF_INET6 - ipv6type - 设置传输类型 SOCK_STREAM(默认值) - tcp SOCK_DGRAM - udp"""# 创建一个基于ipv4和TCP的套接字对象server = socket.socket()# 2.绑定ip地址和端口"""bind((ip地址, 端口号))ip地址 - 服务器对应的计算机的ip地址，字符串端口号 - 用来区分计算机上不同服务; 是一个数字，范围是0~65535; 但是其中1024以下的是著名端口，用来表示一个特殊的服务,一般不要用; 同一时间一个端口只能对应一个服务"""server.bind(('10.7.187.149', 8081))# 3.开始监听"""listen(最大监听数) 最大监听数 - 用来设置当前服务器一次可以处理多少个请求"""server.listen(100)print('开始监听')# 4. 让服务一直处于启动状态while True: # 5.接收客户端发送的请求，返回建立的会话和客户端地址； # 注意，这段代码会阻塞线程(程序运行到这儿会停下来，直到有客户端给当前服务器发送请求为止) conversation, addr = server.accept() print('接收到请求:', addr) # 6.接收消息(客户端发送给服务器的消息) """ recv(缓存大小) - 获取客户端给服务器发送的数据，返回值是二进制 缓存大小 - 决定一次可以接收的数据的最大字节数 这儿也会阻塞线程，直到客户端发送了消息才会接着往后执行 """ re_data = conversation.recv(1024) print('======') print(re_data.decode('utf-8')) # 7.发送数据(服务器给客户端发送数据) """ send(数据) - 将指定的数据发送给客户端 数据 - 要求是二进制 字符串(str)转二进制(bytes): a.bytes(字符串, 'utf-8') b.字符串.encode('utf-8') 二进制转字符串 a.str(二进制数据, 'utf-8') b.二进制.decode('utf-8') """ # message = 'HTTP/1.1 200 OK\r\n\r\n &lt;html&gt;&lt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt;你好!&lt;/body&gt;&lt;/html&gt;' message = '你好！！！' # conversation.send(bytes(message, encoding='utf-8')) conversation.send(message.encode(encoding='utf-8')) # 8.关闭连接 conversation.close() 二、客户端套接字123456789101112131415161718import socket# 1.创建套接字对象client = socket.socket()# 2.连接服务器"""connect((ip, 端口))"""client.connect(('172.21.203.2', 8088))# 3.发送消息message = input('&gt;&gt;')client.send(message.encode('utf-8'))# 4.接收消息re_data = client.recv(1024)print(re_data.decode('utf-8')) 三、网络请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requests"""python中去做http请求，需要使用一个第三方库: requests""""""get(url, 参数字典) - 返回响应"""# 1.向服务器发送get请求# a.手动拼接url# url = 'https://www.apiopen.top/satinApi?type=1&amp;page=1'# response = requests.get(url)# print(response)# b.自动拼接urlurl = 'https://www.apiopen.top/satinApi'response = requests.get(url, &#123;'type': 1, 'page': 1&#125;)print(response)# 2.获取响应头header = response.headersprint(header)# 3.获取响应体"""a.获取二进制格式的响应体"""content = response.contentprint(type(content))"""b.获取json格式响应体 - 自动将json数据转换成python"""json = response.json()print(type(json))"""c.获取字符串格式的响应体"""text = response.textprint(type(text))# 应用：下载网络图片url = 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b10000_10000&amp;sec=1543395098&amp;di=2a5bbaa5600097b050ba69a688672de9&amp;src=http://p0.qhimgs4.com/t0112e7ebfdef7f923d.jpg'response = requests.get(url)image_data = response.contentwith open('王也.jpg', 'wb') as f: f.write(image_data)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用终端命令]]></title>
    <url>%2F2018%2F12%2F22%2FLinux%2F</url>
    <content type="text"><![CDATA[基本指令下面四个为ubantu安装更新命令sudo apt install 软件名 安装软件 sudo apt remove 软件名 卸载软件 sudo apt update 更新可用软件列表 sudo apt upgrade 更新已安装的包 常用文件指令命令 对应英文 作用ls list 查看当前文件夹的内容pwd print work directory 查看当前所在文件夹cd 【目录名】 change directory 切换文件夹touch【文件名】 touch 如果文件不存在，新建文件mkdir【目录名】 make directory 创建目录rm 【文件名】 remove 删除指定文件clear clear 清屏 vim 文本文件 修改文本内容 esc 修改输入方式 :wq 保存并退出 :q! 强制退出删除目录 rm -r 目录名 rm -i 文件或目录 rm -f 强制删除 –help 和 man 显示…..命令的帮助信息例：touch –help 或者 man touch使用man时的操作操作键 功能空格键 显示手册页的下一屏Enter 一次滚动手册页的一行b 回滚一屏f 前滚一屏q 退出/word 搜索word字符串 以.开头的文件为隐藏文件，需要用-a参数才能显示.代表当前目录..代表上一级目录 快捷键ctr + f - 前进一个字符ctr + b - 后退一个字符ctr + a - 回到行首ctr + e - 回到行尾ctr + w - 向左删除一个单词ctr + u - 向左删除全部ctr + k - 向右删除全部ctr + y - 粘贴上次删除的内容ctr + l - 清屏 ls的通配符12345* 代表任意个字符？ 代表一个字符 [] 表示匹配字符组中的任意一个[abc] 表示匹配a、b、c中的任意一个[a-f] 表示匹配a到f范围内的任意一个字符 cd命令常用参数（更改当前工作目录）cd ~ 或cd 切换当前用户的主目录（/home/用户目录）cd. 保持当前目录不变cd.. 切换到上级目录cd - 可以在最近两次工作目录之间来回切换 mkdir -p 可以递归创建目录 如a/b/c/d 命令 对应英文 作用tree[目录名] tree 以树状图列出文件目录结构cp 源文件 目录文件 copy 复制文件或目录mv 源文件 目标文件 move 移动文件或者目录/文件 或者目录重命名 -I 在执行cp或mv有提示作用 cat 文件名 concatenate 查看文件内容、创建文件、合并、追加文件内容等功能more 文件名 more 分屏显示文件内容grep 搜索文本文件文件名 grep 搜索文本文件内容 cat 适合查看文件内容较少的文件 more 适合查看文件内容较多的文件grep -n 显示匹配行及行号 -v显示不包括匹配文本的所有行 -i忽略大小写 echo 重定向 管道 |一个命令的输出 可以通过管道 作为 另一个命令的输入 例： ls -lh | more 高级命令shutdown 关机/重新启动 -r 重新启动shutdown -c 取消关机shutdown -r now 立刻重启 Ctrl c 可以中断 终端命令 命令 对应英文 作用ifconfig configure a network interface 查看/配置计算机当前网卡信息ping ip 地址 ping 检测目标ip地址的连接是否正常 ssh 用户名@ip secure shell 关机/重新启动scp 用户名@ip:文件名或路径​ 用户名@ip:文件名或路径 secure copy 远程复制文件 网络管理常见服务器端口SSH 服务器 22Web 服务器 80HTTPS 443FTP 服务器 21 ifconfig 查看网卡状态 netstat -natp - 查看网络连接状态netstat -natp|grep 端口号 - 查看指定端口的网络连接状态 ping 地址ping -i 时间 地址ping -c 次数 地址 telnet ip地址 端口 - 查看远程主机网络连接状况 dig 地址 - 查看DNSwget 地址 - 下载 scp -P port 01.py user@remote:Desktop/01.py​ 端口 原文件 远程复制的文件 SSH 高级 免密码登录 配置公匙 ssh-keygen 即可生成SSH 钥匙，回车即可 上传公匙到服务器 ssh-copy-id -p port user@remote,可以让服务器记住公匙 权限管理chmod可以修改文件或目录的权限chmod +/- rwx 文件名或目录名 目录 拥有者权限 组权限 其他用户权限文件权限示例 - r w - r w - r - -目录权限示例 d r w x r w x r - x 组管理 终端命令 命令 作用 groupadd 组名 添加组 useradd -G 分组列表 添加组到指定目录 groupdel 组名 删除组 cat/etc/group 确认组信息 chgrp 组名 文件/目录名 递归修改文件/目录所属组 用户管理 终端命令 命令 作用 说明 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户目录 -g 指定用户所在的组，否则会建立一个同名的组 passwd 用户名 设置用户密码 如果是普通用户，可直接使用passwd修改自己的账户密码 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 cat/ect/passwd | grep 用户名 确认用户信息 新建用户后，用户信息会保存在/etc/passwd 文件中 查看用户信息 命令 作用 id [用户名] 查看用户UID和GID信息 who 查看当前所用登录的用户列表 whoami 查看当前登录用户的账户名 passwd文件/etc/passwd 文件存放的是用户信息，由6个分号组成的7个信息1.用户名2.密码（x：表示加密的密码）3.UID （用户标识）4.GID （组标识）5.用户全名或本地账号6.家目录7.登录使用的 Shell，就是登录之后使用的终端命令，ubantu默认是dash usermod 修改用户登录 shellusermod -s /bin/bash 用户名 /etc/passwd 是用于保护用户信息的文件/usr/bin/passwd 是用于修改用户的密码 which 命令可以查看执行命令所在的位置which ls 输出–&gt; /bin/lswhich useradd 输出–&gt; /usr/sbin/useradd 命令 作用 说明su -用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变exit 退出当前用户 su 不接用户名，可以切换到root，但不推荐使用，因为不安全 chown 修改拥有者chgrp 修改组chmod 修改权限 递归修改文件权限chmod -R 755 文件名|目录名 拥有者 组 其他 r w x r w x r w x 4 2 1 4 2 1 4 2 1 0:表示没有权限 4 2 1 7 rwx4 2 0 6 rw-4 0 1 5 r-x4 0 0 4 r–0 2 1 3 -wx0 2 0 2 -w-0 0 1 1 –x0 0 0 0 — 系统信息相关命令时间和日期date 查看系统时间cal calendar查看日历，-y选项可以查看一年的日历 df -h disk free显示磁盘的剩余空间du -h[目录名] disk usage显示目录下的文件大小 进程信息ps aux process status 查看进程的详细状况top 动态显示运行中的进程并且排序kill [-9]进程代号 终止指定代号的进程，-9表示强行终止 a 显示终端上的所有进程，包括其他用户的进程u 显示进程的详细状态x 显示没有控制终端的进程 find [路径] -name “.py” 查找指定路径的扩展名是.py的文件，包括子目录 ln -s 被链接的源文件链接文件 建立文件的软连接，类似window的快捷方式 ———链接文件的路径要使用绝对路径 打包和解压tar 打包/解包tar -cvf 打包文件.tar 被打包的文件/路径…tar -xvf 解包文件.tar c 生成档案文件，创建打包文件x 解开档案文件v 列出归档解档的详细过程，显示进度f 制定档案文件名称，f后面一定是.tar文件，所以必须放选项最后压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件/路径…解压缩文件tar -zxvf 解包文件.tar.gz解压缩到指定路径tar -zxvf 解包文件.tar.gz -C目标路径 bzip2压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径…解压文件tar -jxvf 解包文件.tar.bz2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法]]></title>
    <url>%2F2018%2F12%2F22%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[10 11Python是一种解释型、面向对象、动态数据类型的高级程序设计语言 原码、反码、补码原码：规定了字节数，写明了符号位，就得到数据的原码反码：正数的反码是其原码，负数的反码是其原码的符号位不动，其他位取反 编译型语言–&gt;编译器–&gt;最终可执行文件 操作系统（windows/Linux/Mac）–&gt;CPU解释型语言–&gt;解释器（逐行解释每一句源代码） IDE ：继承开发环境 Linux下重置pycharm1、关闭正在运行的pycharm2、rm -r ~/.pycharm2018.23、重启pycharm 注释：1# 内容（#后应添加一个空格，以保持代码整齐） 关于代码规范 http://www.python.org/dev/peps/pep-0008/ 谷歌对应中文文档： http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 算术运算符// ：取整数 例： 9 // 2 ——&gt;4% ：取余数 例： 9 % 2 ——&gt;1 ：幂（次方）例： 2 3 —-&gt;8变量的类型数字型 整数型 int 浮点型 float 布尔型 bool 复数型 complex ：主要用于科学计算非数字型 字符串 列表 元祖 字典数据反转参考（ https://blog.csdn.net/weixin_41829272/article/details/80851720 ） 10 12格式化字符 含义%s 字符串%d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方用0补全%f 浮点数，%.02f 表示小数点后显示两位%% 输出% 代码缩进为一个tab键，或者4个空格 ———建议使用空格Ctrl 加 / 表示快速注释 逻辑运算符and 与or 或者not 非 10 13随机数import random 导入工具包random.randint() 随机整数 程序开发的三大流程-顺序：从上到下，按顺序执行代码-分支：根据条件判断，决定执行代码的分支-循环：让特定代码重复执行break 和 continuebreak：某一条件满足时，退出循环，不在执行后续重复的代码continue ：某一条件满足时，不执行后续重复的代码 print 自动换行问题print(“内容” end = “”) 取消自动换行 10 14函数具有独立功能的代码块 在需要的时候调用语法： def 函数名(): 函数封装的代码 …….函数的调用： 函数名（）函数文档注释：函数内使用””” 内容 “”” 在调用函数处使用Ctrl +q 查看 形参和实参形参：定义函数时，小括号里的参数，是用来接收参数的，在函数内部作为 变量使用实参：调用函数时，小括号里的参数，是用来把数据传递到 函数内部 使用的 函数的返回值return 表示返回，后续的代码都不会执行 高级变量类型列表元祖字典字符串 列表：在其他语言中通常叫 数组 列表用[]定义，数据之间使用 , 分隔 索引从0开始 语法：例 names = [“张三”,”李四”]列表常用操作方法增加 列表.insert(索引，数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表修改 列表[索引] = 数据 修改指定索引的数据删除 del 列表[索引] 删除索引的数据 列表.remove(数据) 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表统计 len(列表) 列表长度 列表.count(数据) 统计在列表中出现的次数排序 列表.sort() 升序排序 列表.sort(reverse = True) 降序排序 列表.reverse() 逆序、反转循环遍历： 从头到尾依次从列表中获取数据 在循环内部针对每一个元素，执行相同的操作 元组： 由多个元素组成的序列 与列表相似，不同之处 元组元素不能修改元组用()定义 10 15字典：字典用{}定义 字典使用键值对存储数据，键值对之间使用 , 分隔 键 key 是索引（必须是不可变类型的变量） 值 value 是数据 （可以是任意类型） 键和值之间使用 : 分隔 键必须是唯一的 值可以取任何数据类型，但 键只能使用字符串、数字、元组 字符串常用方法：查找与替换 变量名.startswith () 以…开头 .endswith () 以…结束 .find () 指定查找内容 .replace () 替换对齐 .center() 居中对齐 .ljust() 左对齐 .rjust() 右对齐去掉空白字符 .strip() 去除空白字符拆分和连接 .split() 拆分 返回一个列表类型 .join() 连接 返回一个字符串类型 字符串的切片 切片 使用索引值来限定范围，从一个大的字符串中切出小的字符串 语法： 字符串[开始索引 : 结束索引：步长]index ：如果指定的字符串不存在，会报错find ：如果指定的字符串不存在，会返回-1 10 16公共方法python内置函数len() 计算容器中元素的个数del() 删除变量max() 返回容器中元素的最大值 如果是字典只对key比较min() 返回容器中元素的最小值 如果是字典只对key比较**注意：字典没有大小比较成员运算符： in 和 not in完整的for循环语法： for 变量 in 集合: 循环体代码 else: 没有通过break退出循环，循环执行后，会执行的代码 pycharm中TODO注释在 # 后跟上 TODO，用于标记需要去做的工作1#！ ：叫做Shebang 或者 Sha-bang 指明 执行这个脚本文件的解释程序 10 17 变量高级1.变量引用2.可变类型（列表、字典）和不可变类型3.局部变量和全局变量 局部变量：在函数内部定义，只能在函数内部使用函数执行后，函数内部的局部变量，会被系统回收 不同函数，可以定义相同名字的局部变量，互不影响 全局变量：在函数外部定义的变量，所有函数内部都能使用这个变量 在函数内部，可以通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用（使用赋值语句修改全局变量的值） 在函数内部可以使用 global 关键字修改全局变量 语法： num = 10 def demo(): global num #声明num为全局变量 num = 99 #修改 注意：在开发时，应该把 所有的全局变量 定义在所有函数的上方 交换两个数字a = 6b = 100解法一： 使用临时变量 c = b b = a a = c 解法二： 不使用临时变量 a = a + b b = a - b a = a - b 解法三：Python专有，使用元组 a,b = b,a (等号右边是一个元组，只是把小括号省略了) 函数的参数 符号 += ：在Python中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用2.缺省参数：可以给某个参数 指定一个默认值，具有默认值的参数叫做 缺省参数注意：必须保证所有带有默认值的缺省参数在参数列表的末尾 再调用函数时，如果有多个缺省参数，需要指定参数名（明确参数的对应关系） 3.多值参数：需要 一个函数能够处理的参数个数是不确定的时候，可以使用多值参数Python中的两种多值参数 1.参数名前增加一个 * 可以接收元组 2.参数名前增加两个 * 可以接受字典 一般在给多值参数命名时，习惯以下两个名字 - *args ：存放元组参数，前面一个 * - **kwargs ：存放字典参数，前面连个** 说明：*args 是arguments的缩写，有变量意义 kw 是keyword 的缩写， kwargs 可以记忆 键值对参数 拆包：传递参数时 * 表示元组 ** 表示字典 函数的递归函数自己调用自己 特点： 函数内部可以调用自己也可以调用其他函数 代码特点：函数内部的代码是相同的，只是针对参数不同，处理的结果不同 当参数满足一个条件时，函数不在执行（这个非常重要，为递归的出口，否则进入死循环） 10 18控制台改变颜色格式：print( ‘ \033[显示方式;前景色;背景色m ‘ ) 说明： 前景色 背景色 颜色 1234567830 40 黑色31 41 红色32 42 绿色33 43 黃色34 44 蓝色35 45 紫红色36 46 青蓝色37 47 白色 显示方式 意义 1234560 终端默认设置1 高亮显示4 使用下划线5 闪烁7 反白显示8 不可见 10 20面向对象❶封装 1.类和对象： 类：是一个模板，负责创建对象 对象：由类创造出来的一个具体存在 2.类的三要素 类名：满足大驼峰命名法（每个单词首字母大写，单词与单词之间没有下划线） 属性：对对象的特征描述 方法：对象的行为 3.面向对象基础语法： dir内置函数：dir传入标识符/数据，可以查看内置方法/属性 dir( 标识符/数据 ) * 由哪一个对象调用的方法，方法内的 self 就是哪一个对象的引用 –语法：dir(类名) 在类封装的方法内部，self 就表示 当前地哦啊用方法的对象自己 一个对象的 属性 可以是 另一个 类创建的对象 参考（tj_09_oop案例2.py） 4.身份运算符 比较两个对象的内存地址是否一致 —是否是对同一个对象的引用 x is y 类似 id(x) == id (y) x not is y 类似 id(x) != id(y) 5.私有属性和私有方法（不希望公开的） 定义方式：在 属性名或者方法名前增加两个 下划线 如果非要访问： _类名名称❷继承（实现代码的重用） 语法： class 子类（父类）： pass 1.单继承 子类拥有父类的所有方法和属性 2.多继承 子类拥有多个父类，并且具有所有父类的属性和方法 MRO– 方法搜索顺序：内置属性 mro__可以查看方法的搜索顺序—-print(类名，mro) 10 21❸多态（不同的子类对象调用相同的父类方法，产生不同的执行结果） 多态可以增加代码的灵活度 以子类和重写父类的方法为前提 术语—-实例 创建出来的对象叫做类的实例 创建对象的动作叫做实例化 对象的属性叫做实例属性 对象调用的方法叫做实例方法类方法（方法内部字需要访问类属性） 语法： @classmethod def 类方法名(cls): pass 静态方法(方法内部，不需要访问实例属性和类属性，调用时不需要实例化） 语法： @staticmethod def 静态方法名(): pass 单例 单例设计模式：目的（让创建的对象，在系统中只有唯一的一个实例，每一次执行 类名() 返回的对象，内存地址是相同的）1__new__ 方法：由object 基类提供的内置方法 作用： 在内存中为对象分配空间,返回对象的引用捕获异常语法： try: 可能出现异常的代码 except: 出现异常执行的代码 捕获未知错误 语法： except Exception as result: print(&quot;未知错误 %s&quot; %result) 捕获异常 完整语法 ： try: 可能出现异常的代码 except: 出现异常执行的代码 except: 出现异常执行的代码 … except Exception as result: print(“未知错误 %s” %result) else: 没有异常才会执行的代码 finally： 无论是否异常，都会执行的代 10 22模块 模块的别名 语法： import 模块名 as 别名（大驼峰命名） form...import （部分工具导入，导入之后调用不需要使用模块名可以直接使用） form 模块名 import 工具名 注意事项：如果两个模块，存在同名的函数，那么后倒入模块的函数，会覆盖掉先导入的函数 form...import * (导入所有模块工具） __file__可以查看模块的完整路径 （ print(模块名 . __file__) ） __name__内置属性：测试模块的代码只在测试情况下运行，而在被导入时不会被执行 包 包含多个模块的特殊目录 目录下有一个特殊的文件 init.py 包名的命名方式和变量命名一致 文件操作（1个函数 3个方法） open 打开文件，并且返回文件操作对象 read 将文件内容读取到内存 write 将指定内容写入文件 close 关闭文件 打开文件演练： 1.打开（文件名需要注意大小写） file = open(“文件名”) 2.读取 text = file.read() print(text) 3.关闭 file.close()eval 函数 ：将字符串当成有效的表达式来求值并返回计算结果 url统一资源定位符URL基本格式 = 协议://主机地址/路径 HTTP /HTTPs TCP:可靠传输，传输时建立会话UDP:不可靠传输，不会建立会话 10 23进程：正在运行的程序、独立 线程：一个进程想要执行任务，必须要有线程（每1个进程至少要有1条线程） 进程的所有任务都是在线程中执行的线程的串行1个线程中的任务是串行的 多线程：1个进程可以开启多条线程，每1条线程可以并行（同时）执行不同的任务 原理：同一时间，cpu只能处理一条线程，只有1条线程在工作 多个线程之间来回调度（切换]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>自学记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器之神]]></title>
    <url>%2F2018%2F12%2F22%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8B%E7%A5%9E%2F</url>
    <content type="text"><![CDATA[vim编辑器之神配置vimrc配置在shell中可以通过 vim ~/.vimrc 或者 vim /etc/vimrc 打开vimrc文件对vim进行配置。在这个文件中可以进行很多和vim相关的配置，常用的如下（如果对其他配置感兴趣的可以自己百度）： 常用操作1.模式切换我们可以将vim分为命令模式、编辑模式和末行模式三种命令模式：进入vim的时候vim是处于命令模式状态下的，这个时候输入内容不会出现在编辑区 (最末什么都没有) 末行模式：在命令模式下输入冒号，让vim进入末行模式。在末行模式的冒号后面可以输入相关的一些指令进行相关操作 (最后有一个冒号) 编辑模式：在命令模式下按’i’进入编辑模式。在编辑模式下可以对文件内容进行编辑 (最后 –INSERT– 或者 –插入–) ####2.保存和退出在末行模式下输入相应的指令可以对编辑区的内容进行保存和退出vim界面w – 只保存(类似快捷键ctr+s)q – 退出（在编辑区的内容全部都保存的情况下才有效）wq – 保存并退出q! – 强制退出（不保存修改信息） ####3.光标操作以下光标操作都是在命令模式下输入的^(shift+6) – 移动到行首$(shift+4) – 移动到行尾G(shift+g) – 移动到文件末尾行号G – 移动到指定行,例如:30G, 让光标直接跳转到行号是30的那一行gg – 移动到文件开头 ####4.文本操作以下操作不带冒号的是在命令模式下输入，前面有冒号代码后面的内容是在末行模式下输入dd – 删除光标所在的行数字dd – 从光标所在行开始往后面开始删，删除指定数量行内容:%d – 删除所有 yy – 复制光标所在的行数字yy – 从光标所在行开始复制指定行数的内容p – 将复制的内容粘贴到光标所在的位置u – 撤销ctr+r – 反撤销 :%!sort – 对内容排序 :/查找对象[/gice] – 搜索匹配正则表达式的内容，按回车回到命令模式后按n往前查找，按N往后查找 *:1,$s/被替换对象/替换内容[/gice]* – 将正则表达式匹配到的内容替换成指定内容 - g: 全局匹配 - i: 忽略大小写 - c: 替换时需要提示 - e: 忽略错误]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx服务器]]></title>
    <url>%2F2018%2F12%2F22%2FNginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Nginx服务器1.阿里云添加80端口阿里云上默认只有一个22端口用来做远程登录，如果希望在阿里云上安装支持http请求的nginx服务器，需要给阿里云添加80端口 2. 安装nginxa) 添加nginx存储库 1yum install epel-release b) 安装nginx 1yum install nginx c) 运行nginxNginx不会自行启动。要运行Nginx 1systemctl start nginx nginx的运行命令: 12systemctl status nginx 查看nginx的状态 systemctl start/stop/enable/disable nginx 启动/关闭/设置开机启动/禁止开机启动 d) 系统启动时启动Nginx 1systemctl enable nginx e）如果您正在运行防火墙，请运行以下命令以允许HTTP和HTTPS通信： 12345sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload 3.nginx目录共享配置a) 在contOS目录中确定一个需要共享的文件夹，例如： /home/yutingb) 打开 etc/nginx/nginx.conf 文件，设置server 1234567#共享设置 - 在浏览器中输入服务器ip地址，会展示共享目录的文件列表root /home/yuting;location / &#123; autoindex on; autoindex_exact_size on; autoindex_localtime on;&#125; 除了可以共享文件，还可以自定义页面 12345#自定义服务器页面location / &#123; root /home/yuting; index index.html index.htm;&#125; 注意： 如果出现权限问题，可以修改目录的权限 ssh密钥认证1.在主机和从机上执行：ssh-keygen 2.在从机上执行: scp id_rsa.pub root@主机地址:~/.ssh/master.pub(上面这条指令是将从机上的 id_rsa.pub文件拷贝传递给到主机的.ssh文件夹下，并且命名为’master.pub’) 3.在主机中的.ssh文件夹中创建authorized_keys文件： touch authorized_keys 4.修改文件authorized_keys的权限: chmod 600 authorized_keys 5.将master.pub放进authorized_keys文件中: cat master.pub &gt;&gt; authorized_keys 6.在操作主机的时候，需要主机能够自己免密访问自己就将自己的公钥放在自己的authorized_keys文件中]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用指令]]></title>
    <url>%2F2018%2F12%2F22%2Fgit%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git常用指令1.基本指令git init &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 新建git仓库git add 文件/文件夹 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 将文件添加到缓存区中git add -A &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; — 添加所有内容到缓存区中git stutas &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——— 查看git状态git commit -m ‘提交信息’ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 将缓存区中的内容全部提交到git本地仓库中 git log &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——- 查看提交日志 git reset - - hard HEAD &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 让工作目录中的内容和仓库中的内容保持一致git reset --hard HEAD^ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到上一个版本git reset - - hard 版本号 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—— 回到指定的版本git checkout - - 文件名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; —— 从暂存区中恢复工作目录中的内容(让工作区中的指定文件，回到上次提交的时候的状态) git clone &lt;url&gt; - 将服务器上的项目(仓库)克隆 (使用https地址需要输入密码，使用ssh地址需要添加公钥) git remote add origin 地址 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 关联远程仓库(只需要关联一次) git push [-u] origin master &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;—– 提交(-u在第一次提交分之的时候才用) 2.分之管理创建仓库会默认给我们创建一个master分之,这个分之一般作为提交和发布分之;开发一般会自己创建一个develop分之，用来开发和测试;多人协作的时候还可能根据不同的人或者(不同的功能)创建不同的分之，用来独立开发 常见分之： master(主要是合并develop), develop(主要合并下面的其他分支), 功能/人员分之(开发) git branch [-a] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 查看分之git branch 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 创建分之git checkout 分支名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 切换分之git checkout -b 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - 切换并创建新的分之git diff 分之1 分之2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 查看两个分之之间的差异git merge 分之名 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 让当前分之和指定分之进行合并 注意: 切换分之、push、pull，这些操作前要保证工作区是clean 怎么避免冲突： 不要发生多个分之对同一个文件在同一个版本下进行修改(和同伴确认和商量)]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ssh免密登陆及登陆失败后的解决办法]]></title>
    <url>%2F2018%2F12%2F21%2Fssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[这篇文章主要给大家介绍了关于centos配置ssh免密码登录以及登录后仍要输入密码的解决方法,需要的朋友可以参考下 首先，我们需要明白为什么要设置SSH免密码登录，其原因是我们在开启服务器的时候需要多次输入yes和root密码，这是我们所不能忍受的，我们迫切需要实现免登录的功能 第一步：在本机中创建秘钥1.执行命令： ssh-keygen -t rsa -C “xx@qq.com“(随便编个字符串，一般用邮箱）注意事项2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件注意事项：①在liunx环境下，要想复制公钥或是私钥，不要使用vim等编辑器打开文件来复制粘贴；因为它会产生不必要的回车。②应该使用cat把内容打印到终端上再来复制粘贴； 第二步：用 ssh-copy-id 把公钥复制到远程主机上ssh-copy-id zhangming@192.168.161.132把秘钥拷贝到远程服务器 用这种方式拷贝使用的端口是Linux默认的22，如果你想指定端口，可以使用： ssh-copy-id -i /用户名/.ssh/id_rsa.pub ‘-p 端口号 用户名@106.75.52.44’ ssh-copy-id -i /root/.ssh/id_rsa.pub ‘-p 22222 root@106.75.52.44‘这里可能需要等一段时间，反正我是等了挺久的时间，然后显示要你输入密码： zhangming@106.75.52.44‘s password:输入完密码后，显示：Now try logging into the machine, with “ssh ‘-p 22222 root@106.75.52.44‘“, and check in: .ssh/authorized_keysto make sure we haven’t added extra keys that you weren’t expecting.表示成功了！ 第三步：远程登入 [zhangming@localhost ~]$ ssh zhangming@192.168.161.134Last login: Mon Oct 10 14:18:54 2016 from 192.168.161.135ssh zhangming@123.59.44.56 -p 22222 注意 遇到的大坑：配置ssh免密码登录后，仍提示输入密码 解决方法：首先我们就要去查看系统的日志文件cat /var/log/secure 发现问题的所在：Authentication refused: bad ownership or modes for file从字面上可以看出是目录的属主和权限配置不当，查找资料得知：SSH不希望home目录和~/.ssh目录对组有写权限，通过下面几条命令改下 g-w /home/zhangmingchmod 700 /home/zhangming/.sshchmod 600 /home/zhangming/.ssh/authorized_keys然后我们再去登录，就能不用密码进入了。12]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Hello</tag>
        <tag>World</tag>
      </tags>
  </entry>
</search>
